10 REM APPLEMS - AppleSoft MS-BASIC Compatibility Layer (extended)
20 REM Load and RUN this file to get helper subroutines that emulate a small subset of MS-BASIC.
30 REM Author: Generated by copilot
40 REM -----------------------------------------------------------------------------
100 REM --- Demo/startup ---------------------------------------------------------
110 HOME
120 PRINT "APPLEMS - MS-BASIC Compatibility Layer (extended)"
130 PRINT
140 PRINT "Demo: LEFT$, RIGHT$, INSTR, INTDIV, MOD, STR$, VAL, CHR$, ASC, ARR, INPUT"
150 PRINT
160 S$ = "HELLO, WORLD"
170 N = 5
180 REM LEFT$ example: set S$ and N then GOSUB 3000; result in R$
190 S$ = S$: N = 5
200 GOSUB 3000 : PRINT "LEFT$(";S$;",";N;") -> "; R$
210 REM RIGHT$ example: set S$ and N then GOSUB 3100; result in R$
220 S$ = "APPLESOFT" : N = 4
230 GOSUB 3100 : PRINT "RIGHT$(";S$;",";N;") -> "; R$
240 REM INSTR example: set S$, T$ then GOSUB 3300; result in P
250 S$ = "THE QUICK BROWN FOX" : T$ = "BROWN"
260 GOSUB 3300 : PRINT "INSTR(";S$;",";T$;") -> "; P
270 REM INTDIV and MOD example: set A and B then GOSUB 4000/4100
280 A = -17 : B = 4
290 GOSUB 4000 : PRINT "INTDIV(";A;",";B;") -> "; Q
300 GOSUB 4100 : PRINT "MOD(";A;",";B;") -> "; R
310 REM STR$ example: set N then GOSUB 6000 -> R$
320 N = -12.5 : GOSUB 6000 : PRINT "STR$(";N;") -> <"; R$;">"
330 REM VAL example: set R$ then GOSUB 6100 -> RN
340 R$ = " 123.45" : GOSUB 6100 : PRINT "VAL(";R$;") -> "; RN
350 REM CHR$/ASC example
360 N = 65 : GOSUB 6200 : PRINT "CHR$(65) -> "; R$
370 R$ = "A" : GOSUB 6300 : PRINT "ASC(";R$;") -> "; RN
380 REM Array emulation demo
390 GOSUB 7000 : REM initializes array named "X" size 5 in global ARSTR$
400 FOR I = 1 TO 5
410 V = I * 10
420 IDX = I : GOSUB 7100 : REM ARRSET stores V into index IDX
430 NEXT I
440 FOR I = 1 TO 5
450 IDX = I : GOSUB 7200 : PRINT "ARR(X,";I;") -> "; RN
460 NEXT I
470 REM INPUT demo
480 P$ = "Enter your name: " : GOSUB 5000 : PRINT "You entered: "; R$
490 PRINT
500 PRINT "End of extended demo."
510 END

3000 REM LEFT$ (inputs: S$, N) -> output: R$
3010 R$ = ""
3020 IF N <= 0 THEN R$ = "" : RETURN
3030 IF N >= LEN(S$) THEN R$ = S$ : RETURN
3040 R$ = MID$(S$,1,N)
3050 RETURN

3100 REM RIGHT$ (inputs: S$, N) -> output: R$
3110 L = LEN(S$)
3120 IF N <= 0 THEN R$ = "" : RETURN
3130 IF N >= L THEN R$ = S$ : RETURN
3140 R$ = MID$(S$,L-N+1,N)
3150 RETURN

3300 REM INSTR (inputs: S$, T$) -> output: P (1-based index, 0 if not found)
3310 P = 0
3320 LS = LEN(S$) : LT = LEN(T$)
3330 IF LT = 0 THEN P = 1 : RETURN
3340 IF LT > LS THEN P = 0 : RETURN
3350 FOR I = 1 TO LS - LT + 1
3360 IF MID$(S$,I,LT) = T$ THEN P = I : RETURN
3370 NEXT I
3380 P = 0
3390 RETURN

4000 REM INTDIV (inputs: A, B) -> output: Q (integer division truncated toward zero)
4010 IF B = 0 THEN Q = 0 : RETURN
4020 AN = A : BN = B
4030 SA = 1 : IF AN < 0 THEN SA = -1 : AN = -AN
4040 SB = 1 : IF BN < 0 THEN SB = -1 : BN = -BN
4050 Q = INT(AN / BN)
4060 IF SA * SB < 0 THEN Q = -Q
4070 RETURN

4100 REM MOD (inputs: A, B) -> output: R (remainder matching INTDIV above)
4110 IF B = 0 THEN R = 0 : RETURN
4120 GOSUB 4000 : REM computes Q
4130 R = A - Q * B
4140 RETURN

5000 REM MS-INPUT (prompt in P$) -> result in R$
5010 R$ = ""
5020 PRINT P$;
5030 INPUT I$
5040 R$ = I$
5050 RETURN

6000 REM STR$ wrapper (input: N) -> output: R$
6010 R$ = STR$(N)
6020 REM STR$ in many BASICs prefixes positive numbers with a space; strip leading space
6030 IF LEFT$(R$,1) = " " THEN R$ = MID$(R$,2,LEN(R$)-1)
6040 RETURN

6100 REM VAL wrapper (input: R$) -> output: RN
6110 RN = VAL(R$)
6120 RETURN

6200 REM CHR$ wrapper (input: N) -> output: R$
6210 R$ = CHR$(N)
6220 RETURN

6300 REM ASC wrapper (input: R$) -> output: RN
6310 RN = ASC(LEFT$(R$,1))
6320 RETURN

7000 REM ARRINIT (input: ANAME$ in ANAME$, size in ASIZE) -> global ARSTR$ stores fields as "v1|v2|..."
7010 ARNAME$ = "X" : IF ANAME$ <> "" THEN ARNAME$ = ANAME$
7020 ARSTR$ = ""
7030 FOR I = 1 TO ASIZE
7040 IF I = 1 THEN ARSTR$ = "0" ELSE ARSTR$ = ARSTR$ + "|0"
7050 NEXT I
7060 RETURN

7100 REM ARRSET (input: IDX, VAL) uses ARSTR$ for array named in ARNAME$; store value into field IDX
7110 RN = 0
7120 IF IDX < 1 THEN RETURN
7130 FCOUNT = 1
7140 S = ARSTR$;
7150 P1 = 1
7160 FOR I = 1 TO LEN(S)
7170 IF MID$(S,I,1) = "|" THEN FCOUNT = FCOUNT + 1
7180 NEXT I
7190 IF IDX > FCOUNT THEN RETURN
7200 OUT$ = ""
7210 FOR J = 1 TO IDX-1
7220 IF J = 1 THEN POS = INSTR(S,"|") ELSE POS = POS + INSTR(MID$(S,POS+1,LEN(S)),"|")
7230 NEXT J
7240 REM simpler rebuild: split by fields
7250 FPOS = 1
7260 FOR K = 1 TO FCOUNT
7270 NEXT K
7280 REM split loop
7290 F$ = ""
7300 CUR = 1
7310 FOR I = 1 TO LEN(S)
7320 IF MID$(S,I,1) = "|" THEN
7330 IF CUR = IDX THEN F$ = F$ + "" : REM placeholder
7340 CUR = CUR + 1
7350 ELSE
7360 END IF
7370 NEXT I
7380 REM --- simpler approach: use FOR to extract fields via INSTR
7390 REM build new ARSTR$
7400 NEW$ = ""
7410 POS = 1
7420 FOR F = 1 TO FCOUNT
7430 SEP = INSTR(MID$(S,POS,LEN(S)-POS+1),"|")
7440 IF SEP = 0 THEN FIELD$ = MID$(S,POS,LEN(S)-POS+1) ELSE FIELD$ = MID$(S,POS,SEP-1)
7450 IF F = IDX THEN FIELD$ = STR$(VAL) ELSE FIELD$ = FIELD$
7460 IF F = 1 THEN NEW$ = FIELD$ ELSE NEW$ = NEW$ + "|" + FIELD$
7470 IF SEP = 0 THEN EXIT FOR
7480 POS = POS + SEP
7490 NEXT F
7500 ARSTR$ = NEW$
7510 RETURN

7200 REM ARRGET (input: IDX) -> output: RN
7210 RN = 0
7220 IF IDX < 1 THEN RN = 0 : RETURN
7230 S = ARSTR$;
7240 POS = 1
7250 FOUND = 0
7260 FOR F = 1 TO 1000
7270 SEP = INSTR(MID$(S,POS,LEN(S)-POS+1),"|")
7280 IF SEP = 0 THEN FIELD$ = MID$(S,POS,LEN(S)-POS+1) ELSE FIELD$ = MID$(S,POS,SEP-1)
7290 IF F = IDX THEN RN = VAL(FIELD$) : RETURN
7300 IF SEP = 0 THEN EXIT FOR
7310 POS = POS + SEP
7320 NEXT F
7330 RN = 0
7340 RETURN

8000 REM ERROR messages (simple mapping)
8010 REM Input ERRNUM and get ERRMSG$
8020 ON ERR GOTO 0
8030 RETURN

9990 REM END OF LIBRARY
9999 RETURN
